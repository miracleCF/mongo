#pragma once

#include <memory>
#include <queue>

#include "mongo/executor/task_executor.h"
#include "mongo/s/query/cluster_client_cursor.h"
#include "mongo/s/query/cluster_client_cursor_params.h"
#include "mongo/s/query/router_exec_stage.h"
#include "mongo/util/net/hostandport.h"
//include the r-tree related headers
#include "mongo/s/rtree/rtree_globle.h"
#include "cluster_client_cursor_impl.h"


//for unique_ptr in std namespace
#include "mongo/stdx/memory.h"

namespace mongo {

class RouterStageMock;


class RTreeNearClusterClientCursorImpl final :public ClusterClientCursor
{
    MONGO_DISALLOW_COPYING(RTreeNearClusterClientCursorImpl);
public:
    /**
     * Constructs a CCC whose safe cleanup is ensured by an RAII object.
     */
    static ClusterClientCursorGuard make(executor::TaskExecutor* executor,
                                         ClusterClientCursorParams&& params);
    /**
     * we override the make function for R-tree
     */
    static ClusterClientCursorGuard make(OperationContext* txn,
                                           string DB_NAME,
                                           string COLLECTION_NAME,
                                           double ctx,
                                           double cty,
                                           double rMin,
                                           double rMax);
    /**
     * Constructs a CCC whose result set is generated by a mock execution stage.
     */
    RTreeNearClusterClientCursorImpl (std::unique_ptr<RouterStageMock> root);

    StatusWith<boost::optional<BSONObj>> next() final;

    void kill() final;

    bool isTailable() const final;

    long long getNumReturnedSoFar() const final;

    void queueResult(const BSONObj& obj) final;

    bool remotesExhausted() final;
    
    Status setAwaitDataTimeout(Milliseconds awaitDataTimeout) final;

    void setExhausted(bool isExhausted);

private:
    /**
     * Constructs a cluster client cursor.
     */
    RTreeNearClusterClientCursorImpl(executor::TaskExecutor* executor, ClusterClientCursorParams&& params);
    
    /**
     * we override the constructor for R-tree 
     */
    RTreeNearClusterClientCursorImpl(OperationContext* txn,
                                         string DB_NAME,
                                         string COLLECTION_NAME,
                                         double ctx,
                                         double cty,
                                         double rMin,
                                         double rMax);
    
    /**
     * Constructs the pipeline of MergerPlanStages which will be used to answer the query.
     */
    std::unique_ptr<RouterExecStage> buildMergerPlan(executor::TaskExecutor* executor,
                                                     ClusterClientCursorParams&& params);
                                                     
    /*
     * -1: undefined
     *  0: $geoIntersects
     *  1: $geoWithin
     */                                                 
    int _rtreeQuertType=-1;
    
    bool _isRtreeCursorOK=false;
    
    bool _isExhausted = false;

    /**
     * this is the Inner r-tree cursor implemented in mongo/s/rtree
     * this cursor is generated in the constructor, run in the next() and killed in the kill()
     */
    std::unique_ptr<RTreeGeoNearCurosr> _rtreeGeoNearCursor;
    
    bool _isTailable = false;

    // Number of documents already returned by next().
    long long _numReturnedSoFar = 0;

    // The root stage of the pipeline used to return the result set, merged from the remote nodes.
    std::unique_ptr<RouterExecStage> _root;

    // Stores documents queued by queueResult(). Stashed BSONObjs must be owned.
    std::queue<BSONObj> _stash;
};





}